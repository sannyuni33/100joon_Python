def solution(phone_book):
    answer = True

    phone_book.sort()

    for i in range(len(phone_book)-1):
        if phone_book[i] == phone_book[i+1][:len(phone_book[i])]:
            answer = False
            break

    return answer


# solution(["119", "97674223", "1195524421"])
# solution(["123", "456", "789"])
solution(["12", "123", "1523", "567", "88"])

# 다른 번호의 접두어인 경우가 하나라도 있으면 False 를 리턴하고 끝내기.
# 0번째 숫자로 분류를 하면? ([0]은 0으로 시작하는 숫자, [1]은 1로 시작...)
# 그러면 다른 행에 있는 숫자의 접두사가 될 수가 없다.

# 이렇게 나눠도 최악의 경우를 생각하면,
# 1로 시작하는 100만개의 전화번호가 모두 20의 길이를 가진 경우.
# 같은 전화번호는 없다 했으니 나눠주는 의미가 없다고 봐도 무방하다.
# 근데 길이가 같은 번호끼린 접두어가 될 수 없으니 True 를 리턴해야한다.
# 분류 후 비교하는 방법은 아무리 생각해도 시간초과가 날 수 밖에 없다.

# 이 문제가 해시 파트라는 점에 착안해서,,,
# 각 전화번호를 빠르게 비교할 수 있는 값으로 변환해주는 해시 함수를 고안해보자.
# 단, 해시 충돌을 피해야한다.
# 여기서 맨 앞 숫자와 자릿수를 가지고 해시함수를 만들 수 있을래나.
# 그것만 가지고는 부족할 것 같은데...

# 아니면 해시 충돌을 이용해서 같은 해시값을 갖는 애들끼리 비교할 순 없을까
# 그럼 12, 123, 1235, 12357654574544324732 가 같은 해시값을 갖게 해야한단 소리

# 결국 오픈소스를 참조했는데, 해시는 안쓰고 다 그냥 for 문을 돌려버리네...
# 시간초과나 오류 일으키는 테스트 케이스가 있을걸로 예상해서 시도 안했는디 ...

# 일단 시도는 해보자...!