n = int(input())
time2Withdraw = [int(x) for x in input().split()]  # 한 줄에 정수 여러 개 입력은 이렇게
time2Withdraw.sort()
res, dp = 0, 0
for x in time2Withdraw:
    res += int(x)
    dp += res
print(dp)

#
# res = 0
# for x in time2Withdraw:
#     res += n*int(x)
#     n -= 1
# print(res)

# 예제 입출력을 보면 결국 시간 조금 걸리는 사람이 맨 앞으로 오면 되는거.
# 정렬한다음에 DP 방식으로 더하면 끝?
# DP 방식도 필요한데 방금 머리에 떠오른 건
# 1 번째는 n 곱해서, 2 번째는 n-1 곱해서, ... 마지막은 1곱해서 더하면 가능.
# 뭐가 더 시간이랑 메모리 덜 먹는지 해보자
# n 부터 1 까지 곱하기 하니까 틀렸다는디?
# dp로 했는데도 틀렸다? 그럼 이건 정렬부분에서 틀렸다는 것 같은데
# 그냥 오름차순 정렬 돌리면 틀리는거여?
# 아놔 문자열로 받고 그걸 정렬해서 틀린거 ... '10'이 '3'보다 먼저나옴.

# 여러개 정수 입력받는 방법 터득 후... 두 알고리즘을 모두 테스트 해보았음.
# 메모리랑 시간이 둘 다 정확히 같게 든다?????
# 하지만 문제 취지가 DP 연습하는것인걸 생각하자!

# 백준에서 가장 짧게 코딩한사람 코드를 보니까

# b=t=0
# for i in sorted(map(int,[*open(0)][1].split())):b+=i;t+=b
# print(t)

# 요렇게 짜놨는데 pypy3 기준으로 메모리는 121804KB, 시간은 156 ms 걸림.
# Python3 로 돌리니까 메모리, 시간 둘 다 내꺼랑 똑같음. => 앞으로 본받을 코드!