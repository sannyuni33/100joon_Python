n = int(input())
lst = list(map(int, input().split()))
DP = [0 for _ in range(n)]

for i in range(n):
    for j in range(i):
        if lst[j] < lst[i] and DP[j] > DP[i]:
            DP[i] = DP[j]
    DP[i] += 1
print(max(DP))
# 10 20 10 30 20 50 => 10 20 30 50 => 4 라는 예제만 보면
# 오름차순만 유지되게끔 이전보다 작은 숫자가 나왔을 때 빼주면 될 것 같지만,
# 1 9 2 3 4 5 6 7 8 같은 경우는 9 만 빼주면 문제 요구조건에 맞다.

# 이 두 예제에 공통적으로 적용될 수 있는 알고리즘이 멀까.
# n 이 있으면 n - n-1 이랑 n+1 - n 을 비교해보면...?
# 직전요소보다 작으면 그 작은애를 제끼는게 아니라
# 그 큰 직전요소를 빼준다면 어떻게 생각해

# 와 진짜 모르게따. 구글 찬스 사용했더니
# 새로운 유형의 DP 문제였삼. 공부하자... 가장 긴 길이 증가수열 만들기...!

# 배열의 n 번째 요소 차례일 때 가장 긴 증가수열 길이를 확인하고 싶다면
# 1, 2, 3 ... n-1 번째까지 보면서
# "지보다 작은 수중 가장 긴 길이를 가진애의 길이를 가져오고" 거기다가 1 더한다.
# 1을 더하는 이유는 자기 자신이 더해지니까 길이가 1 늘어나는 거.
