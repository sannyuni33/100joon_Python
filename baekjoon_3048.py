res = ""
n1, n2 = map(int, input().split())
ant1 = list(input())
ant1 = ant1[::-1]  # 왼쪽 그룹은 뒤집어져서 조우
ant2 = list(input())
t = int(input())
ant1 += ant2
for i in range(n1):
    ant1[i] = [ant1[i], 'R']  # 첫 번째 그룹은 오른쪽으로 진행
for j in range(n1, n1 + n2):
    ant1[j] = [ant1[j], 'L']  # 두 번째 그룹은 왼쪽으로 진행

while t > 0:
    tmp = 0
    while tmp < len(ant1)-1:
        if ant1[tmp][1] == 'R' and ant1[tmp+1][1] == 'L':
            ant1[tmp], ant1[tmp+1] = ant1[tmp+1], ant1[tmp]
            tmp += 2
        else:
            tmp += 1
    t -= 1

for x in ant1:
    res += x[0]
print(res)

# 두 리스트를 입력받지만 하나의 리스트로 합쳐서 처리하는 방식으로 접근해야하지 싶다.

# 반대방향으로 가는애들끼리 마주치면 서로 '자리를 바꾼다' 라고 이해해야 할 듯
# 지금 당장 떠오르는건 '방향 속성' 을 추가해주는것
# for 문 돌리는데 2칸씩 띄어서 돌리고, i 랑 i+1 번째를 비교하면서 방향이다르면 바꿔주기
# 이 for 문을 t 번 돌리면 해결될 것임
# 문제에서 설명하는 자리바꾸기 메커니즘을 그대로 따라가는 해결방법.

# 여기서 중요하게 생각해볼 것은 합쳐진 리스트의 0번째 부터 시작하기보다는
# 가운데서부터 양쪽으로 퍼져나가는 형태. 예제 입력 1을 생각해보면,
# 맨 처음에는 가운데 두 개미가 자리를 바꿨고, 그 다음은 가운데 네 개미가 자리를 바꿨고
# 그 다음은 가운데 여섯(모든 개미), 그 다음은 다시 가운데 넷, 다음은 가운데 둘..
# 이 법칙성을 잘만 이해하면 굳이 방향 속성이 필요 없겠다..!
# 두 그룹의 길이를 더했을때 홀수인지 짝수인지만 잘 구별해서 ...!

# ~~~가 아니다. 가운데가 아니라 두 그룹이 만난 부분에서 부터 출발해야지.
# 예를 들어 ABCDE 랑 MN 이 만났다고 쳐. 그럼 EDCBAMN 이 되는데, A 랑 M 이 처음으로 바뀜
# 가운데가 아니라 처음 만났던 부분에서부터 시작해야하는거.
# 그러고 또 하나 생각해야 될 문제는, 더 짧은애의 길이 X 2만큼 자리바꾸기 했어도
# T가 충분히 크다면 짧은 그룹은 킵고잉해야함.

# 또 다른 접근 방법은, n1 와 n2, 그리고 t로 푸는 법.
# t에 맞춰서 몇 번째 개미는 반대쪽 그룹에서 어디쯤 위치할런지 예측 후 바꿔준 뒤 출력
#

# 방향 변수 추가해서 정답요..! 시간은 68ms
# 백준에서 제일 빠른 코드봤는데 동일한 알고리즘