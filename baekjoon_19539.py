n = int(input())
appleTrees = list(map(int, input().split()))
print(*appleTrees)

for i in range(len(appleTrees)):
    appleTrees[i] = appleTrees[i] % 3
print(*appleTrees)
c1 = appleTrees.count(1)
c2 = appleTrees.count(2)
if c1 == c2:
    print("YES")
else:
    print("NO")
# 그리디 알고리즘은 그때그때 최적일것 같은 답을 선택한다...
# 이 문제에 적용한다면 어떻게 될까
# 1과 2 로 사과나무들을 모두 만들 수 있냐없냐를 따진다..

# 일단 생각나는건 첫번째 나무를 3으로 나누고 남은 나머지를
# 두번째 나무에 더해주고, 이 더해준것까지 3으로 나누고 남은 나머지를
# 세번째 나무에 ... 해서 끝까지 하면 되나? 라고 생각해봤는데
# 그렇게하면 1 3 1 3 1 도 가능하다고 뜨지만 정답은 NO 임.
# 그 이유는 1과 2의 사용횟수가 동일해야하기 때문임
# 1 3 1 3 1 에 위 알고리즘을 적용하면 2는 두 번, 1은 다섯 번 사용됨.

# 그러면 모든 나무들을 3으로 나눈 나머지만 남겨버리고
# 그 나머지가 1인 애들의 수와 2인 애들의 수를 비교해서
# 같으면 YES 다르면 NO 하면 안되나
# 그럼 그렇게 하면 10000 1000 100 은 출력이 YES 여야 되는데 NO 로 뜬다

# 그럼 10000 1000 100 은 어떤 과정을 거쳐서 YES 가 될까..
# 한 나무를 3만큼 키우거나 두 나무를 각각 1 2만큼 키우거나. 두 가지 경우만 있음
# 나무나무마다 이렇게 하는게 최적일거같은데? 를 찾아보라는말 아닐까...

# 맨 처음 나무를 3으로 나눈 나머지가 1이면 다음 나무에서 2를 뺀다.
# 3으로 나눈 나머지가 2면 다음 나무에서 1을 뺀다.
# 빼고 남은 나머지를 3으로 나누고, 그 나머지에 맞춰서 다음나무에서 빼는과정 반복
# 1과 2의 사용횟수를 맞춰주기 위한 알고리즘임.
# 이거를 했을때는 10000 1000 100 가 맞게 나오지만, 문제는 나무높이들이 2미만일땐
# 어떻게 처리해줄거냐는거임. 예를 들면 1 3 1 3 1. 2를 빼면 음수가 되니깐.

# 1 3 1 3 1 만들기나 3 3 1 1 1 만들기나 똑같음.
# 1은 못나뉨. 1로만 만들 수 있고, 2는 1+1. 2가 두 개 더 있으면 만들 수 있음
# 그러니까 2로만 이루어져있을땐, 2인 나무의 갯수가 3의 배수일때 가능.
# 1하고 2는 이렇게 처리하고
# 3이상 나무로만 위의 알고리즘을 처리하면?

#