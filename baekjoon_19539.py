n = int(input())
appleTrees = list(map(int, input().split()))

# 그리디 알고리즘은 그때그때 최적일것 같은 답을 선택한다...
# 이 문제에 적용한다면 어떻게 될까
# 1과 2 로 사과나무들을 모두 만들 수 있냐없냐를 따진다..

# 일단 생각나는건 첫번째 나무를 3으로 나누고 남은 나머지를
# 두번째 나무에 더해주고, 이 더해준것까지 3으로 나누고 남은 나머지를
# 세번째 나무에 .... 해서 끝까지 하면 되나? 라고 생각해봤는데
# 그렇게하면 1 3 1 3 1 도 가능하다고 뜨지만 정답은 NO 임.
# 그 이유는 1과 2의 사용횟수가 동일해야하기 때문임
# 1 3 1 3 1 에 위 알고리즘을 적용하면 2는 두 번, 1은 다섯 번 사용됨.
#
