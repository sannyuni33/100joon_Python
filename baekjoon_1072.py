x, y = map(int, input().split())
if x == y:
    print(-1)
else:
    BSrange = [x for x in range(x+1, x+(x//2)+1)]
    print(BSrange)
# tmp = x
# if x == y:
#     print(-1)
# else:
#     init = int((y/x)*100)
#     z = init
#     term = 10**len(str(x))-1
#     while z <= init:
#         x += term
#         y += term
#         z = int((y/x)*100)
#         if z > init:  # 승률의 변화가 감지되었다...!
#             x -= term
#             y -= term
#             for i in range(term):  # 정확히 어디서 변했는지...!
#                 x += 1
#                 y += 1
#                 z = int((y/x)*100)
#                 if z > init:  # 정확히 여기서 변했다...!
#                     break
#     print(x-tmp)

# 1 씩 더해가면서 찾지말구 주기를 두고 더하면서 찾자(시간초과 예방)
# 이것도 시간초과가 걸리는게 ..
# x = 1,000,000,000 이고 y = 0 이면 term 이 100,000,000 이니까 여기서도 겁나 반복.
# term = 10**len(str(x))-1 일땐 시간초과, term = 10000 일땐 틀렸다?

# 아... 근데 이거 이분탐색 문제랬는데...
# 이분탐색의 아이디어는 절반씩 줄여나가는 것.
# 찾고자하는 값은 뭐냐.. init 보다 1 큰거. 또는 init 이 1 커지게 하는 게임 수
# 게임 수의 값을 찾고자하는데, 범위가 명확하지 않은 상태에서 이분탐색을 할 수 있나?
# 범위가 명확하지 않다고 한 이유는 x 와 y 가 같이 1씩 늘어나기 때문임
# 그러면 x 값의 절반만큼을 범위로 정해주고 거기서 안나오면 또 그만큼 더해서 ...?
# 출제의도가 이게 아닐 것 같은디 ...
# 이분탐색을 수행할 범위를 딱 찝을 수 있는지 없는지가 관건

# 진 게임을 가지고 해볼수는 없나... 이긴 게임은 계속 늘어나지만 진 게임 수는 고정
# 근데 소수점을 버리는게 영향을 끼칠 우려가 존재

#