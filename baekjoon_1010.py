t = int(input())
resultList = []
for _ in range(t):
    west, east = map(int, input().split())
    dp2 = 0
    cnt = east-west+2
    for i in range(1, east-west+2):
        tmp, dp1 = 0, 0
        for j in range(1, cnt):  # cnt 대신에 와야할 건 도대체 뭘까.
            tmp += j
            dp1 += tmp
        dp2 += dp1
        cnt -= 1
    resultList.append(dp2)
for x in resultList:
    print(x)
# 강 서쪽 사이트와 강 동쪽 사이트의 번호를 짝지은 순서쌍들의 모임이 하나의 '경우의 수'.
# 하나의 경우의 수는 이런식..
# 경수의 수 = [(S1,E1),(S2,E2),(S3,E3), ... , (Sn,En)]
# 이렇게 생긴 '경우의 수' 리스트가 몇 개나 존재할거냐...를 묻는 문제인데..
# len(경우의 수)를 찍으면 서쪽 사이트의 갯수, n이 찍힐거임.
# 또 한 가지 조건이 다리는 겹칠수 없다는 건데.
# 그 말은 즉 Sn < Sm 일 때 En < Em 이어야 한다는 것.

# 서쪽의 1번 사이트가 동쪽의 몇 번 사이트로 이어지냐에 따라
# 2번 사이트, 3번 사이트가 갈 수 있는 동쪽 사이트의 경우의 수가 달라짐(겹치면 안되니까)
# 그럼 DP로 푸는건가 ... 그럴려면 west, east 를 그냥 정수로 받으면 좀 무리가 있을건데
# 리스트로 받던가 해야하는게 아닌지 ...
# 중복 있는 리스트를 set 으로 형변환하면 중복되는 요소는 삭제가 되긴 함.

# 1번 사이트가 선택한 수까지 슬라이싱으로 잘라버리고 남은애의 길이를 따져보기.
# 예를 들어 서쪽이 4, 동쪽이 7일때 서쪽의 1번은 동쪽의 1, 2, 3, 4를 선택할 수 있음.
# 5를 선택하면 뒤에 애들이 다 고를 수 없으니까 중단.
# 재귀함수를 써야 될래나.

# 순서쌍의 리스트를 만져서 해결할거냐.
# 1 ~ east 의 범위를 가진 리스트를 만질꺼냐
# 둘 다 별로고 경우의 수가 나오는 법칙이 조금 보이는 것 같기도 함.
# 4 7 입력됬을때 서쪽의 1이 동쪽의 1을 고르면
# 4+3+2+1 + 3+2+1 + 2+1 + 1 = 20
# 2를 고르면 3+2+1 + 2+1 + 1 = 10
# 3을 고르면 2+1 + 1 = 4
# 4를 고르면 1 = 1              ... 이런식으로 되는 패턴이 보이고
# 그럼 동쪽 사이트를 하나 늘리면?
# 5+4+3+2+1 + 4+3+2+1 + 3+2+1 + 2+1 + 1
# 4+3+2+1 + 3+2+1 + 2+1 + 1    ... 이렇게 됩니다!
# 이런식으로 더해줄려면 DP 쓰는게 맞아요

# 2 2 를 넣었더니 for 문이 1회 실행
# 1 5 를 넣었더니 5회 실행,
# 13 29를 넣었더니 17회 실행
# for 문 반복횟수 정해주는 식만 잘 정해주면 해결될듯.
# 서쪽의 1번 사이트가 택할 수 있는 범위를 기준으로 해서 for 문을 돌려야겠음.
#